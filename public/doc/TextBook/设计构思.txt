通常　我们在PC-game里会看到一种情况　当主角遇到一个事件时　整个
系统会停下来等候主角　或是游戏里的人永远只有呆呆的站著　直到主角
去启动他们　或是战略游戏中　我方全部攻击完毕後才等敌方攻击　很有
趣的是　这种与现实情况脱节的概念不但在游戏世界大行其道　而且历久
不衰　

    如果你还记得创世记系列里的每一个人物　那最大的功臣末过於创世
记系列逼真的即时系统　所谓即时系统就是说　每个人物都会依据自己的
判断以及对环境的变动做出反应　我们可以理解早期电脑的处理速度远不
如现在　游戏的制作技巧不如现在　要真的作出多工并非容易之事　但现
在的电脑设备以及程式技术都已今非昔比　对一个真的想写出有内函程式
的设技师来说　实在是颇值的考虑的一件事　

    对PC来说　单单一个 cpu要对动辄数百或数千个人或物作出处理　那
系统分给每一个人物的时间将微乎其微　例如程式要让甲在吃饭同时　乙
和丙两人开始战斗　如果是单纯的将系统对每个人物处理　你会发现甲吃
一口饭之後　乙会打丙一下　丙会做出一点反应　很明显的　这不是我们
所乐见的　


    另一种情况来说　我们希望看到甲和乙会对同一个事件做出不同反应
　例如甲看到地上有一个垃圾　会把他捡起来看一看　相对於乙　他确会
判别这是一个垃圾　而做出不理会或是将之拿到垃圾筒丢掉的情况出现　
这种情况当然可以用特殊的程式去指定　但对於有上千个这种人物　你将
会怎麽处理　



    我们开始探讨这一个问题之前　要先将人物可能具备的一些个性区别
出来　



1.姓名
2.性别
3.年龄
4.编号
5.力量
6.智力
7.知识
8.敏捷度
9.体型或体格
10.状态
11.情绪
12.影响
..
..
..

还有许多情况并不一一列出　我们只对这些做一个初步了解　

基本资料　
姓名　年龄和性别是各个不同人物(character)的基本资料　在这个部份中还
可以加入人物的肖像或是人物的图片　如果你是要设计一个中文游戏　最好是
要再加入英文的检定ID(identify)　编号则是对人物做个有效管理　避免出现
天下大乱的情况　

先天情况　
有些游戏会设定人物种族　而有些则设定人物属性　但不管是什麽　都避免不
了每个人物的个别属性　这种属性又分先天後天的不同　有时我们是希望得到
人物的初始值　那这一点就很重要　通常可以考虑的情况有力量　智力　知识
　敏捷和体格(或体型)　其它如种族　人物职业(如果一开始就有不同职业)或
特性也在此类　

後天影响　
当人物得到一些物品或被施法(或是被打的头昏脑涨)　因而影响了况先天属性
等都是属於後天影响　如前述之力量　智力　知识　敏捷和体格　甚至性别等
都可以列入这里　至於使用的格式容後再叙　

即时情况　
这些资料则不停的变动　我们在处里人物时也将不停得取得这些资料　例如人
物的清醒程度　进食状况　情绪影响　目前情况等　取得这些资料可以帮助我
们进一步的处理人物个性　

我们将这些资料整理成一个结构　
struct  char_data
{
    char *              name;                英文鉴别id
    char       cname[MAX_INPUT_LENGTH];      中文名称
    int                 sex;                 性别
    int         class;                       职业
    int             position;                目前情况
    int                 max_hit;             最大生命点数
    int                 mana;                精神力
    int                 max_mana;            最大精神力
    int                 move;                体力
    int                 max_move;            最大体力
    int                 perm_str;            基本力量
    int         perm_int;                    基本智力
    int         perm_wis;                    基本知识
    int         perm_dex;                    基本敏捷
    int             perm_con;                基本体格
    int             mod_str;                 改变力量
    int             mod_int;                 改变智力
    int             mod_wis;                 改变知识
    int             mod_dex;                 改变敏捷
    int             mod_con;                 改变体格
    int                 gold;                金钱
    int                 exp;                 经验
    int                 act;                 目前动作
    int         affected_by;                 目前影响
    int                 hungry;              肌饿程度
};


这样的一个格式当然不能完全表达一个人物的个性　如果真要实作的话
必须要完全仔细的考虑每一个项目　但目前我们只用这一个简单的格式
来继续讨论下去　

我们要让系统对每一个人物有同样的处理(完全均分系统是绝对不智的处
理　这点容後再叙)　所以系统的处理常常是树状的　


         ┌人物一
         ├人物二
         ├  ・
         ├  ・
   系统─┼  ・
         ├  ・
         ├  ・
         ├  ・
         └  ・

这种处理方法当然不能说不好　但是问题是在於如果有其中一个人物被消灭了　
那系统的处理便难以处理　其次的问题是系统必须记住那麽多资料的位址　如果
是资料固定还好　指标还很容易找到　一旦我们的资料有不定长度　记忆体位址
势必天下大乱　而且如果人物不断增长下去　我们该如何定位出一个适当的指标
　所以我们换一个资料处理方法　

　　系统─人物一
            │
        　人物二
        　　│
        　人物三
        　　│
        　人物四
        　　・
　　　　　　・
        　　・
            ・

这种资料处理的方法就是用人物一的指标之一去指向人物二・・・

做法是将人物的结构加上
struct  char_data
{
    CHAR        next;      ***将指标指向下一个人物***

    char *              name;                英文鉴别id
    char       cname[MAX_INPUT_LENGTH];      中文名称
    int                 sex;                 性别
    int         class;                       职业
    int             position;                目前情况
    int                 hit;                 生命点数
    int                 max_hit;             最大生命点数
    int                 mana;                精神力
    .
    .
    .
    .
CHAR 是struct char_data的宣告　我们用这个指标去指向下一个人物　
处理的方法如下　
 CHAR * TempCh;
 for ( TempCh = ch; TempCh != NULL ; TempCh=TempCh->next )
     {
     .................
     .................
     }


这种方法可以让我们对所有的CHAR都处理一遍　而不会有漏掉　
在新增人物时　则将新人物的next指向第一个CHAR...........
删除其中一个人物时　则将指向删除人物的指标指向下一个人物　然後将
记忆体释放掉即可　
